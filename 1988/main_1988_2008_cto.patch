Submodule Loop contains modified content
Submodule Loop befcbcb..d027e15:
diff --git a/Loop/Common/Extensions/GlucoseRangeSchedule.swift b/Loop/Common/Extensions/GlucoseRangeSchedule.swift
index c8ef74fe..ccc75b0b 100644
--- a/Loop/Common/Extensions/GlucoseRangeSchedule.swift
+++ b/Loop/Common/Extensions/GlucoseRangeSchedule.swift
@@ -13,6 +13,9 @@ extension GlucoseRangeSchedule {
     func minQuantity(at date: Date) -> HKQuantity {
         return HKQuantity(unit: unit, doubleValue: value(at: date).minValue)
     }
+    func maxQuantity(at date: Date) -> HKQuantity {
+        return HKQuantity(unit: unit, doubleValue: value(at: date).maxValue)
+    }
 }


diff --git a/Loop/Loop.xcodeproj/project.pbxproj b/Loop/Loop.xcodeproj/project.pbxproj
index 31b6ebff..fb968124 100644
--- a/Loop/Loop.xcodeproj/project.pbxproj
+++ b/Loop/Loop.xcodeproj/project.pbxproj
@@ -331,6 +331,7 @@
 		89F9119424358E4500ECCAF3 /* CarbAbsorptionTime.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89F9119324358E4500ECCAF3 /* CarbAbsorptionTime.swift */; };
 		89F9119624358E6900ECCAF3 /* BolusPickerValues.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89F9119524358E6900ECCAF3 /* BolusPickerValues.swift */; };
 		89FE21AD24AC57E30033F501 /* Collection.swift in Sources */ = {isa = PBXBuildFile; fileRef = 89FE21AC24AC57E30033F501 /* Collection.swift */; };
+		9E1B653A26F7D14E00D5BD24 /* IntegralRetrospectiveCorrection.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9E1B653926F7D14E00D5BD24 /* IntegralRetrospectiveCorrection.swift */; };
 		A90EF53C25DEF06200F32D61 /* PluginManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = C16DA84122E8E112008624C2 /* PluginManager.swift */; };
 		A90EF54425DEF0A000F32D61 /* OSLog.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4374B5EE209D84BE00D17AA8 /* OSLog.swift */; };
 		A91D2A3F26CF0FF80023B075 /* IconTitleSubtitleTableViewCell.swift in Sources */ = {isa = PBXBuildFile; fileRef = A91D2A3E26CF0FF80023B075 /* IconTitleSubtitleTableViewCell.swift */; };
@@ -425,6 +426,7 @@
 		B4E96D5D248A82A2002DABAD /* StatusBarHUDView.xib in Resources */ = {isa = PBXBuildFile; fileRef = B4E96D5C248A82A2002DABAD /* StatusBarHUDView.xib */; };
 		B4F3D25124AF890C0095CE44 /* BluetoothStateManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = B4F3D25024AF890C0095CE44 /* BluetoothStateManager.swift */; };
 		B4FEEF7D24B8A71F00A8DF9B /* DeviceDataManager+DeviceStatus.swift in Sources */ = {isa = PBXBuildFile; fileRef = B4FEEF7C24B8A71F00A8DF9B /* DeviceDataManager+DeviceStatus.swift */; };
+		B633A70E291011EE00A39E1D /* Settings.bundle in Resources */ = {isa = PBXBuildFile; fileRef = B633A70D291011EE00A39E1D /* Settings.bundle */; };
 		C1004DF22981F5B700B8CF94 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = C1004DF02981F5B700B8CF94 /* InfoPlist.strings */; };
 		C1004DF52981F5B700B8CF94 /* Localizable.strings in Resources */ = {isa = PBXBuildFile; fileRef = C1004DF32981F5B700B8CF94 /* Localizable.strings */; };
 		C1004DF82981F5B700B8CF94 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = C1004DF62981F5B700B8CF94 /* InfoPlist.strings */; };
@@ -519,6 +521,12 @@
 		C1FB428D21791D2500FAB378 /* PumpManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 43C3B6F620BBCAA30026CAFA /* PumpManager.swift */; };
 		C1FB428F217921D600FAB378 /* PumpManagerUI.swift in Sources */ = {isa = PBXBuildFile; fileRef = C1FB428E217921D600FAB378 /* PumpManagerUI.swift */; };
 		C1FB4290217922A100FAB378 /* PumpManagerUI.swift in Sources */ = {isa = PBXBuildFile; fileRef = C1FB428E217921D600FAB378 /* PumpManagerUI.swift */; };
+		DD3DBD272A33AEC8000F8B5B /* SettingsView+algorithmExperimentsSection.swift in Sources */ = {isa = PBXBuildFile; fileRef = DD3DBD262A33AEC8000F8B5B /* SettingsView+algorithmExperimentsSection.swift */; };
+		DD3DBD292A33AFE9000F8B5B /* IntegralRetrospectiveCorrectionSelectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = DD3DBD282A33AFE9000F8B5B /* IntegralRetrospectiveCorrectionSelectionView.swift */; };
+		DDC389F62A2B61750066E2E8 /* ApplicationFactorStrategy.swift in Sources */ = {isa = PBXBuildFile; fileRef = DDC389F52A2B61750066E2E8 /* ApplicationFactorStrategy.swift */; };
+		DDC389F82A2B620B0066E2E8 /* GlucoseBasedApplicationFactorStrategy.swift in Sources */ = {isa = PBXBuildFile; fileRef = DDC389F72A2B620B0066E2E8 /* GlucoseBasedApplicationFactorStrategy.swift */; };
+		DDC389FA2A2B62470066E2E8 /* ConstantDosingStrategy.swift in Sources */ = {isa = PBXBuildFile; fileRef = DDC389F92A2B62470066E2E8 /* ConstantDosingStrategy.swift */; };
+		DDC389FE2A2C4C830066E2E8 /* GlucoseBasedApplicationFactorSelectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = DDC389FD2A2C4C830066E2E8 /* GlucoseBasedApplicationFactorSelectionView.swift */; };
 		E90909D124E34AC500F963D2 /* high_and_rising_with_cob_momentum_effect.json in Resources */ = {isa = PBXBuildFile; fileRef = E90909CC24E34AC500F963D2 /* high_and_rising_with_cob_momentum_effect.json */; };
 		E90909D224E34AC500F963D2 /* high_and_rising_with_cob_insulin_effect.json in Resources */ = {isa = PBXBuildFile; fileRef = E90909CD24E34AC500F963D2 /* high_and_rising_with_cob_insulin_effect.json */; };
 		E90909D324E34AC500F963D2 /* high_and_rising_with_cob_predicted_glucose.json in Resources */ = {isa = PBXBuildFile; fileRef = E90909CE24E34AC500F963D2 /* high_and_rising_with_cob_predicted_glucose.json */; };
@@ -1319,6 +1327,7 @@
 		89F9119324358E4500ECCAF3 /* CarbAbsorptionTime.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CarbAbsorptionTime.swift; sourceTree = "<group>"; };
 		89F9119524358E6900ECCAF3 /* BolusPickerValues.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BolusPickerValues.swift; sourceTree = "<group>"; };
 		89FE21AC24AC57E30033F501 /* Collection.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Collection.swift; sourceTree = "<group>"; };
+		9E1B653926F7D14E00D5BD24 /* IntegralRetrospectiveCorrection.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = IntegralRetrospectiveCorrection.swift; sourceTree = "<group>"; };
 		A900531A28D60862000BC15B /* Loop.shortcut */ = {isa = PBXFileReference; lastKnownFileType = file; path = Loop.shortcut; sourceTree = "<group>"; };
 		A900531B28D608CA000BC15B /* Cancel Override.shortcut */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Cancel Override.shortcut"; sourceTree = "<group>"; };
 		A900531C28D6090D000BC15B /* Loop Remote Overrides.shortcut */ = {isa = PBXFileReference; lastKnownFileType = file; path = "Loop Remote Overrides.shortcut"; sourceTree = "<group>"; };
@@ -1405,6 +1414,7 @@
 		B4E96D5C248A82A2002DABAD /* StatusBarHUDView.xib */ = {isa = PBXFileReference; lastKnownFileType = file.xib; path = StatusBarHUDView.xib; sourceTree = "<group>"; };
 		B4F3D25024AF890C0095CE44 /* BluetoothStateManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BluetoothStateManager.swift; sourceTree = "<group>"; };
 		B4FEEF7C24B8A71F00A8DF9B /* DeviceDataManager+DeviceStatus.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "DeviceDataManager+DeviceStatus.swift"; sourceTree = "<group>"; };
+		B633A70D291011EE00A39E1D /* Settings.bundle */ = {isa = PBXFileReference; lastKnownFileType = "wrapper.plug-in"; path = Settings.bundle; sourceTree = "<group>"; };
 		C1004DEF2981F5B700B8CF94 /* da */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = da; path = da.lproj/InfoPlist.strings; sourceTree = "<group>"; };
 		C1004DF12981F5B700B8CF94 /* da */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = da; path = da.lproj/InfoPlist.strings; sourceTree = "<group>"; };
 		C1004DF42981F5B700B8CF94 /* da */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = da; path = da.lproj/Localizable.strings; sourceTree = "<group>"; };
@@ -1687,6 +1697,12 @@
 		C1FF3D4B29C786A900BDC1EC /* he */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = he; path = he.lproj/Localizable.strings; sourceTree = "<group>"; };
 		C1FF3D4C29C786A900BDC1EC /* he */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = he; path = he.lproj/Localizable.strings; sourceTree = "<group>"; };
 		C1FF3D4D29C786A900BDC1EC /* he */ = {isa = PBXFileReference; lastKnownFileType = text.plist.strings; name = he; path = he.lproj/InfoPlist.strings; sourceTree = "<group>"; };
+		DD3DBD262A33AEC8000F8B5B /* SettingsView+algorithmExperimentsSection.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "SettingsView+algorithmExperimentsSection.swift"; sourceTree = "<group>"; };
+		DD3DBD282A33AFE9000F8B5B /* IntegralRetrospectiveCorrectionSelectionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = IntegralRetrospectiveCorrectionSelectionView.swift; sourceTree = "<group>"; };
+		DDC389F52A2B61750066E2E8 /* ApplicationFactorStrategy.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ApplicationFactorStrategy.swift; sourceTree = "<group>"; };
+		DDC389F72A2B620B0066E2E8 /* GlucoseBasedApplicationFactorStrategy.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GlucoseBasedApplicationFactorStrategy.swift; sourceTree = "<group>"; };
+		DDC389F92A2B62470066E2E8 /* ConstantDosingStrategy.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ConstantDosingStrategy.swift; sourceTree = "<group>"; };
+		DDC389FD2A2C4C830066E2E8 /* GlucoseBasedApplicationFactorSelectionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GlucoseBasedApplicationFactorSelectionView.swift; sourceTree = "<group>"; };
 		E90909CC24E34AC500F963D2 /* high_and_rising_with_cob_momentum_effect.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = high_and_rising_with_cob_momentum_effect.json; sourceTree = "<group>"; };
 		E90909CD24E34AC500F963D2 /* high_and_rising_with_cob_insulin_effect.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = high_and_rising_with_cob_insulin_effect.json; sourceTree = "<group>"; };
 		E90909CE24E34AC500F963D2 /* high_and_rising_with_cob_predicted_glucose.json */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.json; path = high_and_rising_with_cob_predicted_glucose.json; sourceTree = "<group>"; };
@@ -2030,6 +2046,7 @@
 			children = (
 				43511CDF21FD80E400566C63 /* RetrospectiveCorrection.swift */,
 				43511CE021FD80E400566C63 /* StandardRetrospectiveCorrection.swift */,
+				9E1B653926F7D14E00D5BD24 /* IntegralRetrospectiveCorrection.swift */,
 			);
 			path = RetrospectiveCorrection;
 			sourceTree = "<group>";
@@ -2063,6 +2080,7 @@
 		43776F831B8022E90074EA36 = {
 			isa = PBXGroup;
 			children = (
+				B633A70D291011EE00A39E1D /* Settings.bundle */,
 				C18A491122FCC20B00FDA733 /* Scripts */,
 				4FF4D0FA1E1834BD00846527 /* Common */,
 				43776F8E1B8022E90074EA36 /* Loop */,
@@ -2351,6 +2369,7 @@
 				C13DA2AF24F6C7690098BB29 /* UIViewController.swift */,
 				430B29922041F5B200BA9F93 /* UserDefaults+Loop.swift */,
 				A9B607AF247F000F00792BE4 /* UserNotifications+Loop.swift */,
+				DD3DBD262A33AEC8000F8B5B /* SettingsView+algorithmExperimentsSection.swift */,
 			);
 			path = Extensions;
 			sourceTree = "<group>";
@@ -2400,6 +2419,8 @@
 				43F64DD81D9C92C900D24DC6 /* TitleSubtitleTableViewCell.swift */,
 				4311FB9A1F37FE1B00D4C0A7 /* TitleSubtitleTextFieldTableViewCell.swift */,
 				C1AF062229426300002C1B19 /* ManualGlucoseEntryRow.swift */,
+				DD3DBD282A33AFE9000F8B5B /* IntegralRetrospectiveCorrectionSelectionView.swift */,
+				DDC389FD2A2C4C830066E2E8 /* GlucoseBasedApplicationFactorSelectionView.swift */,
 			);
 			path = Views;
 			sourceTree = "<group>";
@@ -2440,6 +2461,9 @@
 				E9B355232935906B0076AB04 /* Missed Meal Detection */,
 				C1F2075B26D6F9B0007AB7EB /* ProfileExpirationAlerter.swift */,
 				A96DAC2B2838F31200D94E38 /* SharedLogging.swift */,
+				DDC389F52A2B61750066E2E8 /* ApplicationFactorStrategy.swift */,
+				DDC389F72A2B620B0066E2E8 /* GlucoseBasedApplicationFactorStrategy.swift */,
+				DDC389F92A2B62470066E2E8 /* ConstantDosingStrategy.swift */,
 			);
 			path = Managers;
 			sourceTree = "<group>";
@@ -3503,6 +3527,7 @@
 				A966152723EA5A26005D8B29 /* DerivedAssets.xcassets in Resources */,
 				7D70764F1FE06EE1004AC8EA /* InfoPlist.strings in Resources */,
 				7D7076631FE06EE4004AC8EA /* Localizable.strings in Resources */,
+				B633A70E291011EE00A39E1D /* Settings.bundle in Resources */,
 				43776F971B8022E90074EA36 /* Main.storyboard in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -3815,6 +3840,7 @@
 				A9CBE45A248ACBE1008E7BA2 /* DosingDecisionStore+SimulatedCoreData.swift in Sources */,
 				A9C62D8A2331703100535612 /* ServicesManager.swift in Sources */,
 				43DBF0531C93EC8200B3C386 /* DeviceDataManager.swift in Sources */,
+				9E1B653A26F7D14E00D5BD24 /* IntegralRetrospectiveCorrection.swift in Sources */,
 				A9347F2F24E7508A00C99C34 /* WatchHistoricalCarbs.swift in Sources */,
 				A9B996F027235191002DC09C /* LoopWarning.swift in Sources */,
 				C17824A01E19CF9800D9D25C /* GlucoseThresholdTableViewController.swift in Sources */,
@@ -3824,11 +3850,13 @@
 				C1201E2C23ECDBD0002DA84A /* WatchContextRequestUserInfo.swift in Sources */,
 				1D49795824E7289700948F05 /* ServicesViewModel.swift in Sources */,
 				1D4A3E2D2478628500FD601B /* StoredAlert+CoreDataClass.swift in Sources */,
+				DDC389FA2A2B62470066E2E8 /* ConstantDosingStrategy.swift in Sources */,
 				892D7C5123B54A15008A9656 /* CarbEntryViewController.swift in Sources */,
 				B4E202302661063E009421B5 /* ClosedLoopStatus.swift in Sources */,
 				C191D2A125B3ACAA00C26C0B /* DosingStrategySelectionView.swift in Sources */,
 				A977A2F424ACFECF0059C207 /* CriticalEventLogExportManager.swift in Sources */,
 				89CA2B32226C18B8004D9350 /* TestingScenariosTableViewController.swift in Sources */,
+				DD3DBD272A33AEC8000F8B5B /* SettingsView+algorithmExperimentsSection.swift in Sources */,
 				43E93FB71E469A5100EAB8DB /* HKUnit.swift in Sources */,
 				43C05CAF21EB2C24006FB252 /* NSBundle.swift in Sources */,
 				A91D2A3F26CF0FF80023B075 /* IconTitleSubtitleTableViewCell.swift in Sources */,
@@ -3849,6 +3877,7 @@
 				C178249A1E1999FA00D9D25C /* CaseCountable.swift in Sources */,
 				B4F3D25124AF890C0095CE44 /* BluetoothStateManager.swift in Sources */,
 				1DDE273D24AEA4B000796622 /* SettingsViewModel.swift in Sources */,
+				DD3DBD292A33AFE9000F8B5B /* IntegralRetrospectiveCorrectionSelectionView.swift in Sources */,
 				A9347F3124E7521800C99C34 /* CarbBackfillRequestUserInfo.swift in Sources */,
 				A9CBE458248AB564008E7BA2 /* DoseStore+SimulatedCoreData.swift in Sources */,
 				897A5A9924C22DE800C4E71D /* BolusEntryViewModel.swift in Sources */,
@@ -3856,6 +3885,7 @@
 				1DB619AC270BAD3D006C9D07 /* VersionUpdateViewModel.swift in Sources */,
 				A9C62D882331703100535612 /* Service.swift in Sources */,
 				89CAB36324C8FE96009EE3CE /* PredictedGlucoseChartView.swift in Sources */,
+				DDC389F82A2B620B0066E2E8 /* GlucoseBasedApplicationFactorStrategy.swift in Sources */,
 				4F6663941E905FD2009E74FC /* ChartColorPalette+Loop.swift in Sources */,
 				A9F703732489BC8500C98AD8 /* CarbStore+SimulatedCoreData.swift in Sources */,
 				4328E0351CFC0AE100E199AA /* WatchDataManager.swift in Sources */,
@@ -3918,6 +3948,7 @@
 				A97F250825E056D500F0EE19 /* OnboardingManager.swift in Sources */,
 				438D42F91D7C88BC003244B0 /* PredictionInputEffect.swift in Sources */,
 				892A5D692230C41D008961AB /* RangeReplaceableCollection.swift in Sources */,
+				DDC389F62A2B61750066E2E8 /* ApplicationFactorStrategy.swift in Sources */,
 				4F70C2101DE8FAC5006380B7 /* ExtensionDataManager.swift in Sources */,
 				43DFB62320D4CAE7008A7BAE /* PumpManager.swift in Sources */,
 				A9FB75F1252BE320004C7D3F /* BolusDosingDecision.swift in Sources */,
@@ -3926,6 +3957,7 @@
 				431A8C401EC6E8AB00823B9C /* CircleMaskView.swift in Sources */,
 				1D05219D2469F1F5000EBBDE /* AlertStore.swift in Sources */,
 				439897371CD2F80600223065 /* AnalyticsServicesManager.swift in Sources */,
+				DDC389FE2A2C4C830066E2E8 /* GlucoseBasedApplicationFactorSelectionView.swift in Sources */,
 				A9C62D842331700E00535612 /* DiagnosticLog+Subsystem.swift in Sources */,
 				895FE0952201234000FCF18A /* OverrideSelectionViewController.swift in Sources */,
 				C1EF747228D6A44A00C8C083 /* CrashRecoveryManager.swift in Sources */,
diff --git a/Loop/Loop.xcodeproj/xcshareddata/xcschemes/WatchApp.xcscheme b/Loop/Loop.xcodeproj/xcshareddata/xcschemes/WatchApp.xcscheme
index 4e824623..8002b7ef 100644
--- a/Loop/Loop.xcodeproj/xcshareddata/xcschemes/WatchApp.xcscheme
+++ b/Loop/Loop.xcodeproj/xcshareddata/xcschemes/WatchApp.xcscheme
@@ -116,6 +116,15 @@
             ReferencedContainer = "container:Loop.xcodeproj">
          </BuildableReference>
       </BuildableProductRunnable>
+      <MacroExpansion>
+         <BuildableReference
+            BuildableIdentifier = "primary"
+            BlueprintIdentifier = "43A943711B926B7B0051FA24"
+            BuildableName = "WatchApp.app"
+            BlueprintName = "WatchApp"
+            ReferencedContainer = "container:Loop.xcodeproj">
+         </BuildableReference>
+      </MacroExpansion>
    </ProfileAction>
    <AnalyzeAction
       buildConfiguration = "Debug">
diff --git a/Loop/Loop/Extensions/SettingsView+algorithmExperimentsSection.swift b/Loop/Loop/Extensions/SettingsView+algorithmExperimentsSection.swift
new file mode 100644
index 00000000..b094985d
--- /dev/null
+++ b/Loop/Loop/Extensions/SettingsView+algorithmExperimentsSection.swift
@@ -0,0 +1,32 @@
+//
+//  SettingsView+algorithmExperimentsSection.swift
+//  Loop
+//
+//  Created by Jonas Björkert on 2023-06-03.
+//  Copyright © 2023 LoopKit Authors. All rights reserved.
+//
+
+import Foundation
+import SwiftUI
+import LoopKitUI
+
+extension SettingsView {
+    internal var algorithmExperimentsSection: some View {
+        Section(header: SectionHeader(label: NSLocalizedString("Algorithm Experiments ⚠️", comment: "The title of the Algorithm Experiments section in settings"))) {
+            NavigationLink(destination: GlucoseBasedApplicationFactorSelectionView(isGlucoseBasedApplicationFactorEnabled: $isGlucoseBasedApplicationFactorEnabled)) {
+                HStack {
+                    Text("Glucose Based Partial Application")
+                    Spacer()
+                    Text(isGlucoseBasedApplicationFactorEnabled ? "On" : "Off")
+                }
+            }
+            NavigationLink(destination: IntegralRetrospectiveCorrectionSelectionView(isIntegralRetrospectiveCorrectionEnabled: $isIntegralRetrospectiveCorrectionEnabled)) {
+                HStack {
+                    Text("Integral Retrospective Correction")
+                    Spacer()
+                    Text(isIntegralRetrospectiveCorrectionEnabled ? "On" : "Off")
+                }
+            }
+        }
+    }
+}
diff --git a/Loop/Loop/Managers/ApplicationFactorStrategy.swift b/Loop/Loop/Managers/ApplicationFactorStrategy.swift
new file mode 100644
index 00000000..bf67935c
--- /dev/null
+++ b/Loop/Loop/Managers/ApplicationFactorStrategy.swift
@@ -0,0 +1,20 @@
+//
+//  ApplicationFactorStrategy.swift
+//  Loop
+//
+//  Created by Jonas Björkert on 2023-06-03.
+//  Copyright © 2023 LoopKit Authors. All rights reserved.
+//
+
+import Foundation
+import HealthKit
+import LoopKit
+import LoopCore
+
+protocol ApplicationFactorStrategy {
+    func calculateDosingFactor(
+        for glucose: HKQuantity,
+        correctionRangeSchedule: GlucoseRangeSchedule,
+        settings: LoopSettings
+    ) -> Double
+}
diff --git a/Loop/Loop/Managers/ConstantDosingStrategy.swift b/Loop/Loop/Managers/ConstantDosingStrategy.swift
new file mode 100644
index 00000000..0e01cea3
--- /dev/null
+++ b/Loop/Loop/Managers/ConstantDosingStrategy.swift
@@ -0,0 +1,32 @@
+//
+//  ConstantDosingStrategy.swift
+//  Loop
+//
+//  Created by Jonas Björkert on 2023-06-03.
+//  Copyright © 2023 LoopKit Authors. All rights reserved.
+//
+
+import Foundation
+import HealthKit
+import LoopKit
+import LoopCore
+
+struct ConstantDosingStrategy: ApplicationFactorStrategy {
+    func calculateDosingFactor(
+        for glucose: HKQuantity,
+        correctionRangeSchedule: GlucoseRangeSchedule,
+        settings: LoopSettings
+    ) -> Double {
+        // Modify Bolus Application Factor for modified CustomTypeOne LoopPatches
+        //   only effective for ConstantDosingStrategy
+        var constantBolusApplicationFactor = LoopConstants.bolusPartialApplicationFactor
+        let alternatePAFEnabled = UserDefaults.standard.bool(forKey: "alternatePAFEnabled")
+        let alternatePAFSetting = UserDefaults.standard.double(forKey: "alternatePAFSetting")
+        if (alternatePAFEnabled && alternatePAFSetting != 0) {
+            constantBolusApplicationFactor = alternatePAFSetting
+        }
+
+        // The original strategy uses a constant dosing factor.
+        return constantBolusApplicationFactor
+    }
+}
diff --git a/Loop/Loop/Managers/DoseMath.swift b/Loop/Loop/Managers/DoseMath.swift
index e13a3613..009c23e8 100644
--- a/Loop/Loop/Managers/DoseMath.swift
+++ b/Loop/Loop/Managers/DoseMath.swift
@@ -398,13 +398,30 @@ extension Collection where Element: GlucoseValue {
             maxBasalRate = Swift.min(maxThirtyMinuteRateToKeepIOBBelowLimit, maxBasalRate)
         }

-        let temp = correction?.asTempBasal(
+        var temp = correction?.asTempBasal(
             scheduledBasalRate: scheduledBasalRate,
             maxBasalRate: maxBasalRate,
             duration: duration,
             rateRounder: rateRounder
         )

+        // Basal Lock threshold - Jon Fawcett
+        let basalLockEnabled = UserDefaults.standard.bool(forKey: "basalLockEnabled")
+        let basalLockThreshold = UserDefaults.standard.double(forKey: "basalLockThreshold")
+        let glucoseUnit = UserDefaults.standard.string(forKey: "settingsGlucoseUnit")
+        let hkUnit = glucoseUnit == HKUnit.millimolesPerLiter.unitString ? HKUnit.millimolesPerLiter : HKUnit.milligramsPerDeciliter
+
+        if (basalLockEnabled && basalLockThreshold != 0) {
+            if (( temp?.unitsPerHour ?? scheduledBasalRate < scheduledBasalRate  ||
+                 lastTempBasal?.unitsPerHour ?? scheduledBasalRate < scheduledBasalRate
+                 ) &&
+                 self[0 as! Self.Index].quantity > HKQuantity(unit : hkUnit, doubleValue: basalLockThreshold))
+            {
+                print("####### Temp Basal Lock On #########")
+                temp = TempBasalRecommendation(unitsPerHour: scheduledBasalRate, duration: 1800)
+            }
+        }
+
         return temp?.ifNecessary(
             at: date,
             scheduledBasalRate: scheduledBasalRate,
@@ -488,6 +505,23 @@ extension Collection where Element: GlucoseValue {
             volumeRounder: volumeRounder
         )

+        // Basal Lock threshold - Jon Fawcett
+        let basalLockEnabled = UserDefaults.standard.bool(forKey: "basalLockEnabled")
+        let basalLockThreshold = UserDefaults.standard.double(forKey: "basalLockThreshold")
+        let glucoseUnit = UserDefaults.standard.string(forKey: "settingsGlucoseUnit")
+        let hkUnit = glucoseUnit == HKUnit.millimolesPerLiter.unitString ? HKUnit.millimolesPerLiter : HKUnit.milligramsPerDeciliter
+
+        if (basalLockEnabled && basalLockThreshold != 0) {
+            if ( (temp?.unitsPerHour ?? scheduledBasalRate < scheduledBasalRate ||
+                  lastTempBasal?.unitsPerHour ?? scheduledBasalRate < scheduledBasalRate
+                  ) &&
+                 self[0 as! Self.Index].quantity > HKQuantity(unit : hkUnit, doubleValue: basalLockThreshold))
+            {
+                temp = TempBasalRecommendation(unitsPerHour: scheduledBasalRate, duration: 1800)
+                print("####### Temp Basal Lock On #########")
+            }
+        }
+
         if temp != nil || bolusUnits > 0 {
             return AutomaticDoseRecommendation(basalAdjustment: temp, bolusUnits: bolusUnits)
         }
diff --git a/Loop/Loop/Managers/GlucoseBasedApplicationFactorStrategy.swift b/Loop/Loop/Managers/GlucoseBasedApplicationFactorStrategy.swift
new file mode 100644
index 00000000..41caa3d7
--- /dev/null
+++ b/Loop/Loop/Managers/GlucoseBasedApplicationFactorStrategy.swift
@@ -0,0 +1,42 @@
+//
+//  GlucoseBasedApplicationFactorStrategy.swift
+//  Loop
+//
+//  Created by Jonas Björkert on 2023-06-03.
+//  Copyright © 2023 LoopKit Authors. All rights reserved.
+//
+
+import Foundation
+import HealthKit
+import LoopKit
+import LoopCore
+
+struct GlucoseBasedApplicationFactorStrategy: ApplicationFactorStrategy {
+    static let minPartialApplicationFactor = 0.20 // min fraction of correction when glucose > minGlucoseSlidingScale
+    static let maxPartialApplicationFactor = 0.80 // max fraction of correction when glucose > maxGlucoseSlidingScale
+    // set minGlucoseSlidingScale based on user setting for correction range
+    // use mg/dL for calculations
+    static let minGlucoseDeltaSlidingScale = 10.0 // mg/dL
+    static let maxGlucoseSlidingScale = 200.0 // mg/dL
+
+    func calculateDosingFactor(
+        for glucose: HKQuantity,
+        correctionRangeSchedule: GlucoseRangeSchedule,
+        settings: LoopSettings
+    ) -> Double {
+        // Calculate current glucose and lower bound target
+        let currentGlucose = glucose.doubleValue(for: .milligramsPerDeciliter)
+        let correctionRange = correctionRangeSchedule.quantityRange(at: Date())
+        let lowerBoundTarget = correctionRange.lowerBound.doubleValue(for: .milligramsPerDeciliter)
+
+        // Calculate minimum glucose sliding scale and scaling fraction
+        let minGlucoseSlidingScale = GlucoseBasedApplicationFactorStrategy.minGlucoseDeltaSlidingScale + lowerBoundTarget
+        let scalingFraction = (GlucoseBasedApplicationFactorStrategy.maxPartialApplicationFactor - GlucoseBasedApplicationFactorStrategy.minPartialApplicationFactor) / (GlucoseBasedApplicationFactorStrategy.maxGlucoseSlidingScale - minGlucoseSlidingScale)
+        let scalingGlucose = max(currentGlucose - minGlucoseSlidingScale, 0.0)
+
+        // Calculate effectiveBolusApplicationFactor
+        let effectiveBolusApplicationFactor = min(GlucoseBasedApplicationFactorStrategy.minPartialApplicationFactor + scalingGlucose * scalingFraction, GlucoseBasedApplicationFactorStrategy.maxPartialApplicationFactor)
+
+        return effectiveBolusApplicationFactor
+    }
+}
diff --git a/Loop/Loop/Managers/LoopDataManager.swift b/Loop/Loop/Managers/LoopDataManager.swift
index 18a08166..fb2b7d02 100644
--- a/Loop/Loop/Managers/LoopDataManager.swift
+++ b/Loop/Loop/Managers/LoopDataManager.swift
@@ -123,7 +123,7 @@ final class LoopDataManager {

         self.trustedTimeOffset = trustedTimeOffset

-        retrospectiveCorrection = settings.enabledRetrospectiveCorrectionAlgorithm
+        retrospectiveCorrection = settings.enabledRetrospectiveCorrectionAlgorithm()

         overrideIntentObserver = UserDefaults.appGroup?.observe(\.intentExtensionOverrideToSet, options: [.new], changeHandler: {[weak self] (defaults, change) in
             guard let name = change.newValue??.lowercased(), let appGroup = UserDefaults.appGroup else {
@@ -1696,7 +1696,23 @@ extension LoopDataManager {
                     return self.delegate?.roundBolusVolume(units: units) ?? units
                 }

-                let maxAutomaticBolus = min(iobHeadroom, maxBolus! * LoopConstants.bolusPartialApplicationFactor)
+                // Create dosing strategy based on user setting
+                let applicationFactorStrategy: ApplicationFactorStrategy = UserDefaults.standard.bool(forKey: "applyExperimentalGlucoseBasedApplicationFactor")
+                    ? GlucoseBasedApplicationFactorStrategy()
+                    : ConstantDosingStrategy()
+
+                let correctionRangeSchedule = settings.effectiveGlucoseTargetRangeSchedule()
+
+                let effectiveBolusApplicationFactor = applicationFactorStrategy.calculateDosingFactor(
+                    for: glucose.quantity,
+                    correctionRangeSchedule: correctionRangeSchedule!,
+                    settings: settings
+                )
+
+                self.logger.debug(" *** Glucose: %{public}@, effectiveBolusApplicationFactor: %.2f", glucose.quantity.description, effectiveBolusApplicationFactor)
+
+                // If a user customizes maxPartialApplicationFactor > 1; this respects maxBolus
+                let maxAutomaticBolus = min(iobHeadroom, maxBolus! * min(effectiveBolusApplicationFactor, 1.0))

                 dosingRecommendation = predictedGlucose.recommendedAutomaticDose(
                     to: glucoseTargetRange!,
@@ -1706,7 +1722,7 @@ extension LoopDataManager {
                     model: doseStore.insulinModelProvider.model(for: pumpInsulinType),
                     basalRates: basalRateSchedule!,
                     maxAutomaticBolus: maxAutomaticBolus,
-                    partialApplicationFactor: LoopConstants.bolusPartialApplicationFactor * self.timeBasedDoseApplicationFactor,
+                    partialApplicationFactor: effectiveBolusApplicationFactor * self.timeBasedDoseApplicationFactor,
                     lastTempBasal: lastTempBasal,
                     volumeRounder: volumeRounder,
                     rateRounder: rateRounder,
@@ -2102,9 +2118,11 @@ extension LoopDataManager {
                 }),
                 "]",

+                "isExperimentalIntegralRetrospectiveCorrectionEnabled: \(UserDefaults.standard.bool(forKey: "isExperimentalIntegralRetrospectiveCorrectionEnabled"))",
+
                 "retrospectiveGlucoseDiscrepancies: [",
                 "* GlucoseEffect(start, mg/dL)",
-                (state.retrospectiveGlucoseDiscrepancies ?? []).reduce(into: "", { (entries, entry) in
+                (manager.retrospectiveGlucoseDiscrepancies ?? []).reduce(into: "", { (entries, entry) in
                     entries.append("* \(entry.startDate), \(entry.quantity.doubleValue(for: .milligramsPerDeciliter))\n")
                 }),
                 "]",
@@ -2126,6 +2144,7 @@ extension LoopDataManager {
                 "insulinOnBoard: \(String(describing: manager.insulinOnBoard))",
                 "error: \(String(describing: state.error))",
                 "overrideInUserDefaults: \(String(describing: UserDefaults.appGroup?.intentExtensionOverrideToSet))",
+                "applyExperimentalGlucoseBasedApplicationFactor: \(UserDefaults.standard.bool(forKey: "applyExperimentalGlucoseBasedApplicationFactor"))",
                 "",
                 String(reflecting: self.retrospectiveCorrection),
                 "",
diff --git a/Loop/Loop/Models/LoopSettings+Loop.swift b/Loop/Loop/Models/LoopSettings+Loop.swift
index ce7433a9..5f9a650c 100644
--- a/Loop/Loop/Models/LoopSettings+Loop.swift
+++ b/Loop/Loop/Models/LoopSettings+Loop.swift
@@ -21,7 +21,18 @@ extension LoopSettings {
     static let retrospectiveCorrectionEffectDuration = TimeInterval(hours: 1)

     /// Creates an instance of the enabled retrospective correction implementation
-    var enabledRetrospectiveCorrectionAlgorithm: RetrospectiveCorrection {
-        return StandardRetrospectiveCorrection(effectDuration: LoopSettings.retrospectiveCorrectionEffectDuration)
+    func enabledRetrospectiveCorrectionAlgorithm() -> RetrospectiveCorrection {
+        var enabledRetrospectiveCorrectionAlgorithm: RetrospectiveCorrection
+
+        let isIntegralRetrospectiveCorrectionEnabled = UserDefaults.standard.bool(forKey: "isExperimentalIntegralRetrospectiveCorrectionEnabled")
+
+        if isIntegralRetrospectiveCorrectionEnabled {
+            enabledRetrospectiveCorrectionAlgorithm = IntegralRetrospectiveCorrection(effectDuration: LoopSettings.retrospectiveCorrectionEffectDuration)
+        } else {
+            enabledRetrospectiveCorrectionAlgorithm = StandardRetrospectiveCorrection(effectDuration: LoopSettings.retrospectiveCorrectionEffectDuration)
+        }
+
+        return enabledRetrospectiveCorrectionAlgorithm
     }
+
 }
diff --git a/Loop/Loop/Models/RetrospectiveCorrection/IntegralRetrospectiveCorrection.swift b/Loop/Loop/Models/RetrospectiveCorrection/IntegralRetrospectiveCorrection.swift
new file mode 100644
index 00000000..1367f037
--- /dev/null
+++ b/Loop/Loop/Models/RetrospectiveCorrection/IntegralRetrospectiveCorrection.swift
@@ -0,0 +1,226 @@
+//
+//  IntegralRetrospectiveCorrection.swift
+//  Loop
+//
+//  Created by Dragan Maksimovic on 9/19/21.
+//  Copyright © 2021 LoopKit Authors. All rights reserved.
+//
+
+import Foundation
+import HealthKit
+import LoopKit
+import LoopCore
+
+/**
+    Integral Retrospective Correction (IRC) calculates a correction effect in glucose prediction based on a timeline of past discrepancies between observed glucose movement and movement expected based on insulin and carb models. Integral retrospective correction acts as a proportional-integral-differential (PID) controller aimed at reducing modeling errors in glucose prediction.
+
+    In the above summary, "discrepancy" is a difference between the actual glucose and the model predicted glucose over retrospective correction grouping interval (set to 30 min in LoopSettings), whereas "past discrepancies" refers to a timeline of discrepancies computed over retrospective correction integration interval (set to 180 min in Loop Settings).
+
+ */
+class IntegralRetrospectiveCorrection: RetrospectiveCorrection {
+    let retrospectionInterval = TimeInterval(minutes: 180)
+
+    /// RetrospectiveCorrection protocol variables
+    /// Standard effect duration
+    let effectDuration: TimeInterval
+    /// Overall retrospective correction effect
+    var totalGlucoseCorrectionEffect: HKQuantity?
+
+    /**
+     Integral retrospective correction parameters:
+     - currentDiscrepancyGain: Standard retrospective correction gain
+     - persistentDiscrepancyGain: Gain for persistent long-term modeling errors, must be greater than or equal to currentDiscrepancyGain
+     - correctionTimeConstant: How fast integral effect accumulates in response to persistent errors
+     - differentialGain: Differential effect gain
+     - delta: Glucose sampling time interval (5 min)
+     - maximumCorrectionEffectDuration: Maximum duration of the correction effect in glucose prediction
+     - retrospectiveCorrectionIntegrationInterval: Maximum duration over which to integrate retrospective correction changes
+    */
+    static let currentDiscrepancyGain: Double = 1.0
+    static let persistentDiscrepancyGain: Double = 2.0 // was 5.0
+    static let correctionTimeConstant: TimeInterval = TimeInterval(minutes: 60.0) // was 90.0
+    static let differentialGain: Double = 2.0
+    static let delta: TimeInterval = TimeInterval(minutes: 5.0)
+    static let maximumCorrectionEffectDuration: TimeInterval = TimeInterval(minutes: 180.0) // was 240.0
+
+    /// Initialize computed integral retrospective correction parameters
+    static let integralForget: Double = exp( -delta.minutes / correctionTimeConstant.minutes )
+    static let integralGain: Double = ((1 - integralForget) / integralForget) *
+        (persistentDiscrepancyGain - currentDiscrepancyGain)
+    static let proportionalGain: Double = currentDiscrepancyGain - integralGain
+
+    /// All math is performed with glucose expressed in mg/dL
+    private let unit = HKUnit.milligramsPerDeciliter
+
+    /// State variables reported in diagnostic issue report
+    var recentDiscrepancyValues: [Double] = []
+    var integralCorrectionEffectDuration: TimeInterval?
+    var proportionalCorrection: Double = 0.0
+    var integralCorrection: Double = 0.0
+    var differentialCorrection: Double = 0.0
+    var currentDate: Date = Date()
+    var ircStatus: String = "-"
+
+    /**
+     Initialize integral retrospective correction settings based on current values of user settings
+
+     - Parameters:
+        - settings: User settings
+        - insulinSensitivity: User insulin sensitivity schedule
+        - basalRates: User basal rate schedule
+
+     - Returns: Integral Retrospective Correction customized with controller parameters and user settings
+    */
+    init(effectDuration: TimeInterval) {
+        self.effectDuration = effectDuration
+    }
+
+    /**
+     Calculates overall correction effect based on timeline of discrepancies, and updates glucoseCorrectionEffect
+
+     - Parameters:
+     - glucose: Most recent glucose
+     - retrospectiveGlucoseDiscrepanciesSummed: Timeline of past discepancies
+
+     - Returns:
+     - totalRetrospectiveCorrection: Overall glucose effect
+     */
+    func computeEffect(
+        startingAt startingGlucose: GlucoseValue,
+        retrospectiveGlucoseDiscrepanciesSummed: [GlucoseChange]?,
+        recencyInterval: TimeInterval,
+        insulinSensitivitySchedule: InsulinSensitivitySchedule?,
+        basalRateSchedule: BasalRateSchedule?,
+        glucoseCorrectionRangeSchedule: GlucoseRangeSchedule?,
+        retrospectiveCorrectionGroupingInterval: TimeInterval
+        ) -> [GlucoseEffect] {
+
+        // Loop settings relevant for calculation of effect limits
+        // let settings = UserDefaults.appGroup?.loopSettings ?? LoopSettings()
+        currentDate = Date()
+
+        // Last discrepancy should be recent, otherwise clear the effect and return
+        let glucoseDate = startingGlucose.startDate
+        var glucoseCorrectionEffect: [GlucoseEffect] = []
+        guard let currentDiscrepancy = retrospectiveGlucoseDiscrepanciesSummed?.last,
+            glucoseDate.timeIntervalSince(currentDiscrepancy.endDate) <= recencyInterval
+            else {
+                ircStatus = "discrepancy not available, effect not computed."
+                totalGlucoseCorrectionEffect = nil
+                return( [] )
+        }
+
+        // Default values if we are not able to calculate integral retrospective correction
+        ircStatus = "defaulted to standard RC, past discrepancies or user settings not available."
+        let currentDiscrepancyValue = currentDiscrepancy.quantity.doubleValue(for: unit)
+        var scaledCorrection = currentDiscrepancyValue
+        totalGlucoseCorrectionEffect = HKQuantity(unit: unit, doubleValue: currentDiscrepancyValue)
+        integralCorrectionEffectDuration = effectDuration
+
+        // Calculate integral retrospective correction if past discrepancies over integration interval are available and if user settings are available
+        if  let pastDiscrepancies = retrospectiveGlucoseDiscrepanciesSummed?.filterDateRange(glucoseDate.addingTimeInterval(-retrospectionInterval), glucoseDate),
+            let sensitivity = insulinSensitivitySchedule,
+            let basals = basalRateSchedule,
+            let glucoseCorrectionRangeSchedule = glucoseCorrectionRangeSchedule {
+
+            ircStatus = "effect computed successfully."
+
+            // To reduce response delay, integral retrospective correction is computed over an array of recent contiguous discrepancy values having the same sign as the latest discrepancy value
+            recentDiscrepancyValues = []
+            var nextDiscrepancy = currentDiscrepancy
+            let currentDiscrepancySign = currentDiscrepancy.quantity.doubleValue(for: unit).sign
+            for pastDiscrepancy in pastDiscrepancies.reversed() {
+                let pastDiscrepancyValue = pastDiscrepancy.quantity.doubleValue(for: unit)
+                if (pastDiscrepancyValue.sign == currentDiscrepancySign &&
+                    nextDiscrepancy.endDate.timeIntervalSince(pastDiscrepancy.endDate)
+                    <= recencyInterval && abs(pastDiscrepancyValue) >= 0.1)
+                {
+                    recentDiscrepancyValues.append(pastDiscrepancyValue)
+                    nextDiscrepancy = pastDiscrepancy
+                } else {
+                    break
+                }
+            }
+            recentDiscrepancyValues = recentDiscrepancyValues.reversed()
+
+            let currentSensitivity = sensitivity.quantity(at: glucoseDate).doubleValue(for: unit)
+            let currentBasalRate = basals.value(at: glucoseDate)
+            let correctionRangeMin = glucoseCorrectionRangeSchedule.minQuantity(at: glucoseDate).doubleValue(for: unit)
+            let correctionRangeMax = glucoseCorrectionRangeSchedule.maxQuantity(at: glucoseDate).doubleValue(for: unit)
+            let latestGlucoseValue = startingGlucose.quantity.doubleValue(for: unit) // most recent glucose
+
+            // Safety limit for (+) integral effect. The limit is set to a larger value if the current blood glucose is further away from the correction range because we have more time available for corrections
+            let glucoseError = latestGlucoseValue - correctionRangeMax
+            let zeroTempEffect = abs(currentSensitivity * currentBasalRate)
+            let integralEffectPositiveLimit = min(max(glucoseError, 1.0 * zeroTempEffect), 4.0 * zeroTempEffect)
+
+            // Limit for (-) integral effect: glucose prediction reduced by no more than 10 mg/dL below the correction range minimum
+            let integralEffectNegativeLimit = -max(10.0, latestGlucoseValue - correctionRangeMin)
+
+            // Integral effect math
+            integralCorrection = 0.0
+            var integralCorrectionEffectMinutes = effectDuration.minutes - 2.0 * IntegralRetrospectiveCorrection.delta.minutes
+            for discrepancy in recentDiscrepancyValues {
+                integralCorrection =
+                    IntegralRetrospectiveCorrection.integralForget * integralCorrection +
+                    IntegralRetrospectiveCorrection.integralGain * discrepancy
+                integralCorrectionEffectMinutes += 2.0 * IntegralRetrospectiveCorrection.delta.minutes
+            }
+            // Limits applied to integral correction effect and effect duration
+            integralCorrection = min(max(integralCorrection, integralEffectNegativeLimit), integralEffectPositiveLimit)
+            integralCorrectionEffectMinutes = min(integralCorrectionEffectMinutes, IntegralRetrospectiveCorrection.maximumCorrectionEffectDuration.minutes)
+
+            // Differential effect math
+            var differentialDiscrepancy: Double = 0.0
+            if recentDiscrepancyValues.count > 1 {
+                let previousDiscrepancyValue = recentDiscrepancyValues[recentDiscrepancyValues.count - 2]
+                differentialDiscrepancy = currentDiscrepancyValue - previousDiscrepancyValue
+            }
+
+            // Overall glucose effect calculated as a sum of propotional, integral and differential effects
+            proportionalCorrection = IntegralRetrospectiveCorrection.proportionalGain * currentDiscrepancyValue
+            differentialCorrection = IntegralRetrospectiveCorrection.differentialGain * differentialDiscrepancy
+            let totalCorrection = proportionalCorrection + integralCorrection + differentialCorrection
+            totalGlucoseCorrectionEffect = HKQuantity(unit: unit, doubleValue: totalCorrection)
+            integralCorrectionEffectDuration = TimeInterval(minutes: integralCorrectionEffectMinutes)
+
+            // correction value scaled to account for extended effect duration
+            scaledCorrection = totalCorrection * effectDuration.minutes / integralCorrectionEffectDuration!.minutes
+        }
+
+        let retrospectionTimeInterval = currentDiscrepancy.endDate.timeIntervalSince(currentDiscrepancy.startDate)
+        let discrepancyTime = max(retrospectionTimeInterval, retrospectiveCorrectionGroupingInterval)
+        let velocity = HKQuantity(unit: unit.unitDivided(by: .second()), doubleValue: scaledCorrection / discrepancyTime)
+
+        // Update array of glucose correction effects
+        glucoseCorrectionEffect = startingGlucose.decayEffect(atRate: velocity, for: integralCorrectionEffectDuration!)
+
+        // Return glucose correction effects
+        return( glucoseCorrectionEffect )
+    }
+
+    var debugDescription: String {
+        let report: [String] = [
+            "## IntegralRetrospectiveCorrection",
+            "",
+            "Last updated: \(currentDate)",
+            "Status: \(ircStatus)",
+            "currentDiscrepancyGain: \(IntegralRetrospectiveCorrection.currentDiscrepancyGain)",
+            "persistentDiscrepancyGain: \(IntegralRetrospectiveCorrection.persistentDiscrepancyGain)",
+            "correctionTimeConstant [min]: \(IntegralRetrospectiveCorrection.correctionTimeConstant.minutes)",
+            "proportionalGain: \(IntegralRetrospectiveCorrection.proportionalGain)",
+            "integralForget: \(IntegralRetrospectiveCorrection.integralForget)",
+            "integralGain: \(IntegralRetrospectiveCorrection.integralGain)",
+            "differentialGain: \(IntegralRetrospectiveCorrection.differentialGain)",
+            "Integration performed over \(recentDiscrepancyValues.count) most recent discrepancies having the same sign as the latest discrepancy value. Earliest-to-most-recent recentDiscrepancyValues [mg/dL]: \(recentDiscrepancyValues)",
+            "proportionalCorrection [mg/dL]: \(proportionalCorrection)",
+            "integralCorrection [mg/dL]: \(integralCorrection)",
+            "differentialCorrection [mg/dL]: \(differentialCorrection)",
+            "totalGlucoseCorrectionEffect: \(String(describing: totalGlucoseCorrectionEffect))",
+            "integralCorrectionEffectDuration [min]: \(String(describing: integralCorrectionEffectDuration?.minutes))"
+        ]
+
+        return report.joined(separator: "\n")
+    }
+
+}
diff --git a/Loop/Loop/View Controllers/PredictionTableViewController.swift b/Loop/Loop/View Controllers/PredictionTableViewController.swift
index 10ed414a..d681a5e2 100644
--- a/Loop/Loop/View Controllers/PredictionTableViewController.swift
+++ b/Loop/Loop/View Controllers/PredictionTableViewController.swift
@@ -276,9 +276,26 @@ class PredictionTableViewController: LoopChartsTableViewController, Identifiable
                 format: NSLocalizedString("Predicted: %1$@\nActual: %2$@ (%3$@)", comment: "Format string describing retrospective glucose prediction comparison. (1: Predicted glucose)(2: Actual glucose)(3: difference)"),
                 values[0], values[1], values[2]
             )
+            let isIntegralRetrospectiveCorrectionEnabled = UserDefaults.standard.bool(forKey: "isExperimentalIntegralRetrospectiveCorrectionEnabled")
+
+            if isIntegralRetrospectiveCorrectionEnabled {
+                var integralEffectDisplay = "?"
+                var totalEffectDisplay = "?"
+                if let totalEffect = self.totalRetrospectiveCorrection {
+                    let integralEffectValue = totalEffect.doubleValue(for: glucoseChart.glucoseUnit) - lastDiscrepancy.quantity.doubleValue(for: glucoseChart.glucoseUnit)
+                    let integralEffect = HKQuantity(unit: glucoseChart.glucoseUnit, doubleValue: integralEffectValue)
+                    integralEffectDisplay = formatter.string(from: integralEffect, for: glucoseChart.glucoseUnit) ?? "?"
+                    totalEffectDisplay = formatter.string(from: totalEffect, for: glucoseChart.glucoseUnit) ?? "?"
+                }
+                let integralRetro = String(
+                    format: NSLocalizedString("prediction-description-integral-retrospective-correction", comment: "Format string describing integral retrospective correction. (1: Integral glucose effect)(2: Total glucose effect)"),
+                    integralEffectDisplay, totalEffectDisplay
+                )
+                subtitleText = String(format: "%@\n%@", retro, integralRetro)
+            } else {
+                subtitleText = String(format: "%@\n%@", subtitleText, retro)
+            }

-            // Standard retrospective correction
-            subtitleText = String(format: "%@\n%@", subtitleText, retro)
         }

         cell.subtitleLabel?.text = subtitleText
diff --git a/Loop/Loop/Views/GlucoseBasedApplicationFactorSelectionView.swift b/Loop/Loop/Views/GlucoseBasedApplicationFactorSelectionView.swift
new file mode 100644
index 00000000..1e78c81e
--- /dev/null
+++ b/Loop/Loop/Views/GlucoseBasedApplicationFactorSelectionView.swift
@@ -0,0 +1,55 @@
+//
+//  GlucoseBasedApplicationFactorSelectionView.swift
+//  Loop
+//
+//  Created by Jonas Björkert on 2023-06-04.
+//  Copyright © 2023 LoopKit Authors. All rights reserved.
+//
+
+import Foundation
+import SwiftUI
+import LoopKit
+import LoopKitUI
+
+public struct GlucoseBasedApplicationFactorSelectionView: View {
+    @Binding var isGlucoseBasedApplicationFactorEnabled: Bool
+
+    public init(isGlucoseBasedApplicationFactorEnabled: Binding<Bool>) {
+        self._isGlucoseBasedApplicationFactorEnabled = isGlucoseBasedApplicationFactorEnabled
+    }
+
+    public var body: some View {
+        List {
+            automaticBolusSection
+        }
+        .navigationBarTitleDisplayMode(.inline)
+        .toolbar {
+            ToolbarItem(placement: .principal) {
+                VStack {
+                    Text("Glucose Based")
+                        .font(.headline)
+                    Text("Partial Application")
+                        .font(.subheadline)
+                }
+            }
+        }
+    }
+
+    private var automaticBolusSection: some View {
+        VStack {
+            DescriptiveText(label: NSLocalizedString("Active only when Automatic Bolus is selected under Dosing Strategy.\n\nWhen Glucose Based Partial Application is disabled, Automatic Bolus Dosing Strategy uses a constant percentage of 40% when Loop recommends a bolus.\n\nWhen enabled, this experimental feature varies the percentage of recommended bolus delivered each cycle with glucose level. Near correction range, use 20% (similar to Temp Basal). Gradually increase to a maximum of 80% at high glucose (200 mg/dL, 11.1 mmol/L).\n\nPlease be aware that during fast rising glucose, such as after an unannounced meal, this feature, combined with Loop's velocity and retrospective correction effects, may result in a larger dose than your ISF would call for.", comment: "Description of Glucose Based Partial Application toggle."), color: .black)
+            Section() {
+                Toggle(NSLocalizedString("Glucose Based Partial Application", comment: "Title for Glucose Based Partial Application toggle"), isOn: $isGlucoseBasedApplicationFactorEnabled)
+                    .onChange(of: isGlucoseBasedApplicationFactorEnabled) { newValue in
+                        UserDefaults.standard.set(newValue, forKey: "applyExperimentalGlucoseBasedApplicationFactor")
+                    }
+            }
+        }
+    }
+}
+
+struct GlucoseBasedApplicationFactorSelectionView_Previews: PreviewProvider {
+    static var previews: some View {
+        GlucoseBasedApplicationFactorSelectionView(isGlucoseBasedApplicationFactorEnabled: .constant(true))
+    }
+}
diff --git a/Loop/Loop/Views/IntegralRetrospectiveCorrectionSelectionView.swift b/Loop/Loop/Views/IntegralRetrospectiveCorrectionSelectionView.swift
new file mode 100644
index 00000000..daf58750
--- /dev/null
+++ b/Loop/Loop/Views/IntegralRetrospectiveCorrectionSelectionView.swift
@@ -0,0 +1,54 @@
+//
+//  IntegralRetrospectiveCorrectionSelectionView.swift
+//  Loop
+//
+//  Created by Jonas Björkert on 2023-06-04.
+//  Copyright © 2023 LoopKit Authors. All rights reserved.
+//
+import Foundation
+import SwiftUI
+import LoopKit
+import LoopKitUI
+
+public struct IntegralRetrospectiveCorrectionSelectionView: View {
+    @Binding var isIntegralRetrospectiveCorrectionEnabled: Bool
+
+    public init(isIntegralRetrospectiveCorrectionEnabled: Binding<Bool>) {
+        self._isIntegralRetrospectiveCorrectionEnabled = isIntegralRetrospectiveCorrectionEnabled
+    }
+
+    public var body: some View {
+        List {
+            retrospectiveCorrectionSection
+        }
+        .navigationBarTitleDisplayMode(.inline)
+        .toolbar {
+            ToolbarItem(placement: .principal) {
+                VStack {
+                    Text("Integral")
+                        .font(.headline)
+                    Text("Retrospective Correction")
+                        .font(.subheadline)
+                }
+            }
+        }
+    }
+
+    private var retrospectiveCorrectionSection: some View {
+        VStack {
+            DescriptiveText(label: NSLocalizedString("Integral Retrospective Correction (IRC) is an advanced control technique applied to glucose forecasting based on the history of discrepancies between predicted and actual glucose levels. The predictions are made using carbohydrate and insulin data. When enabled, IRC adjusts insulin delivery in response to consistent patterns: it increases insulin delivery when glucose levels consistently measure higher than expected, and decreases it when glucose levels are consistently lower than expected. IRC uses a proportional-integral-differential (PID) controller that adjusts insulin recommendations based on immediate, accumulated, and rate of change discrepancies. This provides a more adaptive and responsive control compared to standard retrospective correction. However, it's important to know that the effectiveness of IRC will heavily depend on the accuracy of your insulin sensitivity, carbohydrate ratios, and basal rates settings. While IRC can improve glucose management in cases of consistent discrepancies, please note that it might potentially lead to more aggressive corrections.", comment: "Description of Integral Retrospective Correction toggle."), color: .black)
+            Section() {
+                Toggle(NSLocalizedString("Integral Retrospective Correction", comment: "Title for Integral Retrospective Correction toggle"), isOn: $isIntegralRetrospectiveCorrectionEnabled)
+                    .onChange(of: isIntegralRetrospectiveCorrectionEnabled) { newValue in
+                        UserDefaults.standard.set(newValue, forKey: "isExperimentalIntegralRetrospectiveCorrectionEnabled")
+                    }
+            }
+        }
+    }
+}
+
+struct IntegralRetrospectiveCorrectionSelectionView_Previews: PreviewProvider {
+    static var previews: some View {
+        IntegralRetrospectiveCorrectionSelectionView(isIntegralRetrospectiveCorrectionEnabled: .constant(true))
+    }
+}
diff --git a/Loop/Loop/Views/SettingsView.swift b/Loop/Loop/Views/SettingsView.swift
index 90859273..a9403b88 100644
--- a/Loop/Loop/Views/SettingsView.swift
+++ b/Loop/Loop/Views/SettingsView.swift
@@ -30,6 +30,8 @@ public struct SettingsView: View {
     @State private var therapySettingsIsPresented: Bool = false
     @State private var deletePumpDataAlertIsPresented = false
     @State private var deleteCGMDataAlertIsPresented = false
+    @State internal var isIntegralRetrospectiveCorrectionEnabled = UserDefaults.standard.bool(forKey: "isExperimentalIntegralRetrospectiveCorrectionEnabled")
+    @State internal var isGlucoseBasedApplicationFactorEnabled = UserDefaults.standard.bool(forKey: "applyExperimentalGlucoseBasedApplicationFactor")

     public init(viewModel: SettingsViewModel) {
         self.viewModel = viewModel
@@ -39,23 +41,28 @@ public struct SettingsView: View {
     public var body: some View {
         NavigationView {
             List {
-                loopSection
-                if versionUpdateViewModel.softwareUpdateAvailable {
-                    softwareUpdateSection
-                }
-                if FeatureFlags.automaticBolusEnabled {
-                    dosingStrategySection
-                }
-                alertManagementSection
-                if viewModel.pumpManagerSettingsViewModel.isSetUp() {
-                    configurationSection
-                }
-                deviceSettingsSection
-                if viewModel.pumpManagerSettingsViewModel.isTestingDevice || viewModel.cgmManagerSettingsViewModel.isTestingDevice {
-                    deleteDataSection
-                }
-                if viewModel.servicesViewModel.showServices {
-                    servicesSection
+                Group {
+                    loopSection
+                    if versionUpdateViewModel.softwareUpdateAvailable {
+                        softwareUpdateSection
+                    }
+                    if FeatureFlags.automaticBolusEnabled {
+                        dosingStrategySection
+                    }
+                    // Note: Experimental Section
+                    algorithmExperimentsSection
+                    //
+                    alertManagementSection
+                    if viewModel.pumpManagerSettingsViewModel.isSetUp() {
+                        configurationSection
+                    }
+                    deviceSettingsSection
+                    if viewModel.pumpManagerSettingsViewModel.isTestingDevice || viewModel.cgmManagerSettingsViewModel.isTestingDevice {
+                        deleteDataSection
+                    }
+                    if viewModel.servicesViewModel.showServices {
+                        servicesSection
+                    }
                 }
                 supportSection
                 if let profileExpiration = Bundle.main.profileExpiration, FeatureFlags.profileExpirationSettingsViewEnabled {
diff --git a/Loop/Loop/en.lproj/Localizable.strings b/Loop/Loop/en.lproj/Localizable.strings
index 78907ea3..54d0ee57 100644
--- a/Loop/Loop/en.lproj/Localizable.strings
+++ b/Loop/Loop/en.lproj/Localizable.strings
@@ -246,6 +246,12 @@
 /* The title text for the issue report cell */
 "Issue Report" = "Issue Report";

+/* Format string describing retrospective glucose prediction comparison. (1: Predicted glucose)(2: Actual glucose)(3: difference) */
+"prediction-description-retrospective-correction" = "Predicted: %1$@\nActual: %2$@ (%3$@)";
+
+/* Format string describing integral retrospective correction. (1: Integral glucose effect)(2: Total glucose effect) */
+"prediction-description-integral-retrospective-correction" = "Integral effect: %1$@\nTotal glucose effect: %2$@";
+
 /* Glucose HUD accessibility hint */
 "Launches CGM app" = "Launches CGM app";

diff --git a/Loop/LoopUI/Charts/COBChart.swift b/Loop/LoopUI/Charts/COBChart.swift
index b8fbfd8f..7c956ddd 100644
--- a/Loop/LoopUI/Charts/COBChart.swift
+++ b/Loop/LoopUI/Charts/COBChart.swift
@@ -63,6 +63,16 @@ public extension COBChart {
         // Grid lines
         let gridLayer = ChartGuideLinesForValuesLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, settings: guideLinesLayerSettings, axisValuesX: Array(xAxisValues.dropFirst().dropLast()), axisValuesY: yAxisValues)

+        // read from Settings->Loop, restart required
+        let addNowMarker = UserDefaults.standard.bool(forKey: "addNowMarkerToCharts")
+
+        var currentTimeSettings = ChartGuideLinesLayerSettings(linesColor: UIColor.carbTintColor, linesWidth: 0.0)
+        let currentTimeValue = ChartAxisValueDate(date: Date(),  formatter: { _ in "" })
+        if addNowMarker {
+            currentTimeSettings = ChartGuideLinesLayerSettings(linesColor: UIColor.carbTintColor, linesWidth: 1.0)
+        }
+        let currentTimeLayer = ChartGuideLinesForValuesLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, settings: currentTimeSettings, axisValuesX: [currentTimeValue], axisValuesY: [])
+
         if gestureRecognizer != nil {
             cobChartCache = ChartPointsTouchHighlightLayerViewCache(
                 xAxisLayer: xAxisLayer,
@@ -76,6 +86,7 @@ public extension COBChart {

         let layers: [ChartLayer?] = [
             gridLayer,
+            currentTimeLayer,
             xAxisLayer,
             yAxisLayer,
             cobChartCache?.highlightLayer,
diff --git a/Loop/LoopUI/Charts/DoseChart.swift b/Loop/LoopUI/Charts/DoseChart.swift
index a2558511..8ddd6191 100644
--- a/Loop/LoopUI/Charts/DoseChart.swift
+++ b/Loop/LoopUI/Charts/DoseChart.swift
@@ -106,6 +106,16 @@ public extension DoseChart {
         // Grid lines
         let gridLayer = ChartGuideLinesForValuesLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, settings: guideLinesLayerSettings, axisValuesX: Array(xAxisValues.dropFirst().dropLast()), axisValuesY: yAxisValues)

+        // read from Settings->Loop, restart required
+        let addNowMarker = UserDefaults.standard.bool(forKey: "addNowMarkerToCharts")
+
+        let currentTimeValue = ChartAxisValueDate(date: Date(), formatter: { _ in "" })
+        var currentTimeSettings = ChartGuideLinesLayerSettings(linesColor: colors.insulinTint, linesWidth: 0.0)
+        if addNowMarker {
+            currentTimeSettings = ChartGuideLinesLayerSettings(linesColor: colors.insulinTint, linesWidth: 1.0)
+        }
+        let currentTimeLayer = ChartGuideLinesForValuesLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, settings: currentTimeSettings, axisValuesX: [currentTimeValue], axisValuesY: [])
+
         // 0-line
         let dummyZeroChartPoint = ChartPoint(x: ChartAxisValueDouble(0), y: ChartAxisValueDouble(0))
         let zeroGuidelineLayer = ChartPointsViewsLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, chartPoints: [dummyZeroChartPoint], viewGenerator: {(chartPointModel, layer, chart) -> UIView? in
@@ -130,6 +140,7 @@ public extension DoseChart {

         let layers: [ChartLayer?] = [
             gridLayer,
+            currentTimeLayer,
             xAxisLayer,
             yAxisLayer,
             zeroGuidelineLayer,
diff --git a/Loop/LoopUI/Charts/IOBChart.swift b/Loop/LoopUI/Charts/IOBChart.swift
index a78699ea..5d6a44ca 100644
--- a/Loop/LoopUI/Charts/IOBChart.swift
+++ b/Loop/LoopUI/Charts/IOBChart.swift
@@ -66,6 +66,16 @@ public extension IOBChart {
         // Grid lines
         let gridLayer = ChartGuideLinesForValuesLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, settings: guideLinesLayerSettings, axisValuesX: Array(xAxisValues.dropFirst().dropLast()), axisValuesY: yAxisValues)

+        // read from Settings->Loop, restart required
+        let addNowMarker = UserDefaults.standard.bool(forKey: "addNowMarkerToCharts")
+
+        let currentTimeValue = ChartAxisValueDate(date: Date(), formatter: { _ in "" })
+        var currentTimeSettings = ChartGuideLinesLayerSettings(linesColor: colors.insulinTint, linesWidth: 0.0)
+        if addNowMarker {
+            currentTimeSettings = ChartGuideLinesLayerSettings(linesColor: colors.insulinTint, linesWidth: 1.0)
+        }
+        let currentTimeLayer = ChartGuideLinesForValuesLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, settings: currentTimeSettings, axisValuesX: [currentTimeValue], axisValuesY: [])
+
         // 0-line
         let dummyZeroChartPoint = ChartPoint(x: ChartAxisValueDouble(0), y: ChartAxisValueDouble(0))
         let zeroGuidelineLayer = ChartPointsViewsLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, chartPoints: [dummyZeroChartPoint], viewGenerator: {(chartPointModel, layer, chart) -> UIView? in
@@ -90,6 +100,7 @@ public extension IOBChart {

         let layers: [ChartLayer?] = [
             gridLayer,
+            currentTimeLayer,
             xAxisLayer,
             yAxisLayer,
             zeroGuidelineLayer,
diff --git a/Loop/LoopUI/Charts/PredictedGlucoseChart.swift b/Loop/LoopUI/Charts/PredictedGlucoseChart.swift
index 01a343d0..c77ac0bc 100644
--- a/Loop/LoopUI/Charts/PredictedGlucoseChart.swift
+++ b/Loop/LoopUI/Charts/PredictedGlucoseChart.swift
@@ -170,6 +170,16 @@ extension PredictedGlucoseChart {
         // Grid lines
         let gridLayer = ChartGuideLinesForValuesLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, settings: guideLinesLayerSettings, axisValuesX: Array(xAxisValues.dropFirst().dropLast()), axisValuesY: yAxisValues)

+        // read from Settings->Loop, restart required
+        let addNowMarker = UserDefaults.standard.bool(forKey: "addNowMarkerToCharts")
+
+        let currentTimeValue = ChartAxisValueDate(date: Date(), formatter: { _ in "" })
+        var currentTimeSettings = ChartGuideLinesLayerSettings(linesColor: colors.glucoseTint, linesWidth: 0.0)
+        if addNowMarker {
+            currentTimeSettings = ChartGuideLinesLayerSettings(linesColor: colors.glucoseTint, linesWidth: 1.0)
+        }
+        let currentTimeLayer = ChartGuideLinesForValuesLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, settings: currentTimeSettings, axisValuesX: [currentTimeValue], axisValuesY: [])
+
         let circles = ChartPointsScatterCirclesLayer(xAxis: xAxisLayer.axis, yAxis: yAxisLayer.axis, chartPoints: glucosePoints, displayDelay: 0, itemSize: CGSize(width: 4, height: 4), itemFillColor: colors.glucoseTint, optimized: true)

         var alternatePrediction: ChartLayer?
@@ -208,6 +218,7 @@ extension PredictedGlucoseChart {

         let layers: [ChartLayer?] = [
             gridLayer,
+            currentTimeLayer,
             targetsLayer,
             xAxisLayer,
             yAxisLayer,
diff --git a/Loop/Settings.bundle/Root.plist b/Loop/Settings.bundle/Root.plist
new file mode 100644
index 00000000..0df628c0
--- /dev/null
+++ b/Loop/Settings.bundle/Root.plist
@@ -0,0 +1,197 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>StringsTable</key>
+	<string>Root</string>
+	<key>PreferenceSpecifiers</key>
+	<array>
+		<dict>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+			<key>Title</key>
+			<string>SWITCHER PATCH REPLACED - USE GLUCOSE BASED PARTIAL APPLICATION IN LOOP, SETTINGS</string>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+			<key>Title</key>
+			<string>Add Now Marker, Main Charts</string>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSToggleSwitchSpecifier</string>
+			<key>Title</key>
+			<string>Enabled</string>
+			<key>Key</key>
+			<string>addNowMarkerToCharts</string>
+			<key>DefaultValue</key>
+			<false/>
+			<key>TrueValue</key>
+			<true/>
+			<key>FalseValue</key>
+			<false/>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+			<key>Title</key>
+			<string>Negative IOB Factor</string>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSMultiValueSpecifier</string>
+			<key>Title</key>
+			<string>Negative IOB Factor</string>
+			<key>Key</key>
+			<string>negativeBasalMultiplier</string>
+			<key>DefaultValue</key>
+			<string>1.0</string>
+			<key>Values</key>
+			<array>
+				<real>0.15</real>
+				<real>0.2</real>
+				<real>0.25</real>
+				<real>0.3</real>
+				<real>0.35</real>
+				<real>0.4</real>
+				<real>0.45</real>
+				<real>0.5</real>
+				<real>0.55</real>
+				<real>0.6</real>
+				<real>0.65</real>
+				<real>0.7</real>
+				<real>0.75</real>
+				<real>0.8</real>
+				<real>0.85</real>
+				<real>0.9</real>
+				<real>0.95</real>
+				<real>1</real>
+			</array>
+			<key>Titles</key>
+			<array>
+				<string>15%</string>
+				<string>20%</string>
+				<string>25%</string>
+				<string>30%</string>
+				<string>35%</string>
+				<string>40%</string>
+				<string>45%</string>
+				<string>50%</string>
+				<string>55%</string>
+				<string>60%</string>
+				<string>65%</string>
+				<string>70%</string>
+				<string>75%</string>
+				<string>80%</string>
+				<string>85%</string>
+				<string>90%</string>
+				<string>95%</string>
+				<string>100%</string>
+			</array>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+			<key>Title</key>
+			<string>VALID ONLY WHEN GLUCOSE BASED PARTIAL APPLICATION NOT ENABLED - CONSTANT PARTIAL APPLICATION</string>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSToggleSwitchSpecifier</string>
+			<key>Title</key>
+			<string>Enabled</string>
+			<key>Key</key>
+			<string>alternatePAFEnabled</string>
+			<key>DefaultValue</key>
+			<false/>
+			<key>TrueValue</key>
+			<true/>
+			<key>FalseValue</key>
+			<false/>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSMultiValueSpecifier</string>
+			<key>Title</key>
+			<string>Alternate Application Factor</string>
+			<key>Key</key>
+			<string>alternatePAFSetting</string>
+			<key>DefaultValue</key>
+			<string>0.4</string>
+			<key>Values</key>
+			<array>
+				<real>0.15</real>
+				<real>0.2</real>
+				<real>0.25</real>
+				<real>0.3</real>
+				<real>0.35</real>
+				<real>0.4</real>
+				<real>0.45</real>
+				<real>0.5</real>
+				<real>0.55</real>
+				<real>0.6</real>
+				<real>0.65</real>
+				<real>0.7</real>
+				<real>0.75</real>
+				<real>0.8</real>
+				<real>0.85</real>
+				<real>0.9</real>
+				<real>0.95</real>
+				<real>1</real>
+			</array>
+			<key>Titles</key>
+			<array>
+				<string>15%</string>
+				<string>20%</string>
+				<string>25%</string>
+				<string>30%</string>
+				<string>35%</string>
+				<string>40%</string>
+				<string>45%</string>
+				<string>50%</string>
+				<string>55%</string>
+				<string>60%</string>
+				<string>65%</string>
+				<string>70%</string>
+				<string>75%</string>
+				<string>80%</string>
+				<string>85%</string>
+				<string>90%</string>
+				<string>95%</string>
+				<string>100%</string>
+			</array>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSGroupSpecifier</string>
+			<key>Title</key>
+			<string>Basal Lock</string>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSToggleSwitchSpecifier</string>
+			<key>Title</key>
+			<string>Enabled</string>
+			<key>Key</key>
+			<string>basalLockEnabled</string>
+			<key>DefaultValue</key>
+			<false/>
+			<key>TrueValue</key>
+			<true/>
+			<key>FalseValue</key>
+			<false/>
+		</dict>
+		<dict>
+			<key>Type</key>
+			<string>PSTextFieldSpecifier</string>
+			<key>Title</key>
+			<string>Basal Lock Threshold</string>
+			<key>Key</key>
+			<string>basalLockThreshold</string>
+			<key>KeyboardType</key>
+			<string>NumbersAndPunctuation</string>
+		</dict>
+	</array>
+</dict>
+</plist>
Submodule LoopKit 9835a29..3dab4bc:
diff --git a/LoopKit/LoopKit/InsulinKit/InsulinMath.swift b/LoopKit/LoopKit/InsulinKit/InsulinMath.swift
index 29c7053..509e631 100644
--- a/LoopKit/LoopKit/InsulinKit/InsulinMath.swift
+++ b/LoopKit/LoopKit/InsulinKit/InsulinMath.swift
@@ -40,10 +40,23 @@ extension DoseEntry {
         }

         // Consider doses within the delta time window as momentary
+        //ken changes
+        //implement user set negative basal multiplier
+        var negativeBasalMultiplier = UserDefaults.standard.double(forKey: "negativeBasalMultiplier")
+        // if user has not modified settings, this value reports as 0 initially
+        // Default shows as 100%, aka, same as unmodified code
+        if negativeBasalMultiplier == 0 {
+            negativeBasalMultiplier = 1
+        }
+        var modifiednetBasalUnits = netBasalUnits
+        if netBasalUnits < 0.0 {
+            modifiednetBasalUnits = netBasalUnits * negativeBasalMultiplier
+        }
+        //this used netBasalUnits as multiplier originally
         if endDate.timeIntervalSince(startDate) <= 1.05 * delta {
-            return netBasalUnits * model.percentEffectRemaining(at: time)
+            return modifiednetBasalUnits * model.percentEffectRemaining(at: time)
         } else {
-            return netBasalUnits * continuousDeliveryInsulinOnBoard(at: date, model: model, delta: delta)
+            return modifiednetBasalUnits * continuousDeliveryInsulinOnBoard(at: date, model: model, delta: delta)
         }
     }

@@ -77,11 +90,23 @@ extension DoseEntry {
         }

         // Consider doses within the delta time window as momentary
-        if endDate.timeIntervalSince(startDate) <= 1.05 * delta {
-            return netBasalUnits * -insulinSensitivity * (1.0 - model.percentEffectRemaining(at: time))
-        } else {
-            return netBasalUnits * -insulinSensitivity * continuousDeliveryGlucoseEffect(at: date, model: model, delta: delta)
-        }
+        //ken changes
+            //if net basal is negative use a mulitplier (0-1)
+            //modified in user settings
+            var negativeBasalMultiplier = UserDefaults.standard.double(forKey: "negativeBasalMultiplier")
+            if negativeBasalMultiplier == 0 {
+                negativeBasalMultiplier = 1
+            }
+            var modifiednetBasalUnits = netBasalUnits
+            if netBasalUnits < 0.0 {
+                modifiednetBasalUnits = netBasalUnits * negativeBasalMultiplier
+            }
+            //originally used netBasalUnits
+            if endDate.timeIntervalSince(startDate) <= 1.05 * delta {
+                return modifiednetBasalUnits * -insulinSensitivity * (1.0 - model.percentEffectRemaining(at: time))
+            } else {
+                return modifiednetBasalUnits * -insulinSensitivity * continuousDeliveryGlucoseEffect(at: date, model: model, delta: delta)
+            }
     }

     func trimmed(from start: Date? = nil, to end: Date? = nil, syncIdentifier: String? = nil) -> DoseEntry {
